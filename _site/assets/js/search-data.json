{"0": {
    "doc": "Zenodo",
    "title": "Zenodo",
    "content": "To use Zenodo module, it is important to obtain a token in Zenodo first. We recommend creating the token in the Sandbox version of Zenodo, in order to generate fictitious DOIs and not make intensive use of the real Zenodo SLA. To generate the Zenodo .env file, run in root project: . cp app/blueprints/zenodo/.env.example app/blueprints/zenodo/.env . To perform the composition of all environment variables, refer to section Composing Environment Variables. ",
    "url": "/docs/modules/zenodo",
    
    "relUrl": "/docs/modules/zenodo"
  },"1": {
    "doc": "Access MariaDB",
    "title": "Access MariaDB",
    "content": " ",
    "url": "/docs/rosemary/managing_database/access_mariadb",
    
    "relUrl": "/docs/rosemary/managing_database/access_mariadb"
  },"2": {
    "doc": "Access MariaDB",
    "title": "Table of contents",
    "content": ". | Access to console | Exit console | . ",
    "url": "/docs/rosemary/managing_database/access_mariadb#table-of-contents",
    
    "relUrl": "/docs/rosemary/managing_database/access_mariadb#table-of-contents"
  },"3": {
    "doc": "Access MariaDB",
    "title": "Access to console",
    "content": "To directly use the MariaDB console to execute native SQL statements, use: . rosemary db:console . This command connects to the MariaDB container using the credentials defined in the .env file. ",
    "url": "/docs/rosemary/managing_database/access_mariadb#access-to-console",
    
    "relUrl": "/docs/rosemary/managing_database/access_mariadb#access-to-console"
  },"4": {
    "doc": "Access MariaDB",
    "title": "Exit console",
    "content": "To exit the MariaDB console, type: . exit; . ",
    "url": "/docs/rosemary/managing_database/access_mariadb#exit-console",
    
    "relUrl": "/docs/rosemary/managing_database/access_mariadb#exit-console"
  },"5": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": "Coming soon… . ",
    "url": "/docs/architecture",
    
    "relUrl": "/docs/architecture"
  },"6": {
    "doc": "Create module",
    "title": "Create module",
    "content": " ",
    "url": "/docs/rosemary/extending_uvlhub/create_module",
    
    "relUrl": "/docs/rosemary/extending_uvlhub/create_module"
  },"7": {
    "doc": "Create module",
    "title": "Table of contents",
    "content": ". | About | Create module | . ",
    "url": "/docs/rosemary/extending_uvlhub/create_module#table-of-contents",
    
    "relUrl": "/docs/rosemary/extending_uvlhub/create_module#table-of-contents"
  },"8": {
    "doc": "Create module",
    "title": "About",
    "content": "To quickly generate a new module within the project, including necessary boilerplate files like __init__.py, routes.py, models.py, repositories.py, services.py, forms.py, and a basic index.html template, you can use the rosemary CLI tool’s make:module command. This command will create a new blueprint structure ready for development. ",
    "url": "/docs/rosemary/extending_uvlhub/create_module#about",
    
    "relUrl": "/docs/rosemary/extending_uvlhub/create_module#about"
  },"9": {
    "doc": "Create module",
    "title": "Create module",
    "content": "To create a new module, run the following command from the root of the project: . rosemary make:module &lt;module_name&gt; . Replace &lt;module_name&gt; with the desired name of your module. This command creates a new directory under app/blueprints/ with the name of your module and sets up the initial files and directories needed to get started, including a dedicated templates directory for your module’s templates. This feature is designed to streamline the development process, making it easy to add new features to the project. Note . If the module with &lt;module_name&gt; already exists, rosemary will simply notify you and not overwrite any existing files. ",
    "url": "/docs/rosemary/extending_uvlhub/create_module",
    
    "relUrl": "/docs/rosemary/extending_uvlhub/create_module"
  },"10": {
    "doc": "Extending uvlhub",
    "title": "Extending uvlhub",
    "content": " ",
    "url": "/docs/rosemary/extending_uvlhub",
    
    "relUrl": "/docs/rosemary/extending_uvlhub"
  },"11": {
    "doc": "Fakenodo",
    "title": "Fakenodo",
    "content": " ",
    "url": "/docs/modules/fakenodo",
    
    "relUrl": "/docs/modules/fakenodo"
  },"12": {
    "doc": "Getting started",
    "title": "Getting started",
    "content": " ",
    "url": "/docs/getting-started/",
    
    "relUrl": "/docs/getting-started/"
  },"13": {
    "doc": "Getting started",
    "title": "Table of contents",
    "content": ". | Clone repo | Environment variables | Deploy in develop | . For development deployment, the use of Docker is recommended. ",
    "url": "/docs/getting-started/#table-of-contents",
    
    "relUrl": "/docs/getting-started/#table-of-contents"
  },"14": {
    "doc": "Getting started",
    "title": "Clone repo",
    "content": "You can start your fantastic development with uvlhub by cloning our official repository. git clone https://github.com/diverso-lab/uvlhub.git cd uvlhub . ",
    "url": "/docs/getting-started/#clone-repo",
    
    "relUrl": "/docs/getting-started/#clone-repo"
  },"15": {
    "doc": "Getting started",
    "title": "Environment variables",
    "content": "To create an .env file according to a basic template, run: . cp .env.example .env . ",
    "url": "/docs/getting-started/#environment-variables",
    
    "relUrl": "/docs/getting-started/#environment-variables"
  },"16": {
    "doc": "Getting started",
    "title": "Deploy in develop",
    "content": "To deploy the software under development environment, run: . docker compose -f docker-compose.dev.yml up -d . This will apply the migrations to the database and run the Flask application. If everything worked correctly, you should see the deployed version of UVLHub in development at http://localhost. ",
    "url": "/docs/getting-started/#deploy-in-develop",
    
    "relUrl": "/docs/getting-started/#deploy-in-develop"
  },"17": {
    "doc": "Home",
    "title": "Welcome to uvlhub docs!",
    "content": "Repository of feature models in UVL format integrated with Zenodo and FlamaPy - DiversoLab . Get started now View it on GitHub . Changelog . Detailed changes for each release are documented in the release notes. ",
    "url": "/#welcome-to-uvlhub-docs",
    
    "relUrl": "/#welcome-to-uvlhub-docs"
  },"18": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"19": {
    "doc": "Installation",
    "title": "Installation",
    "content": "Coming soon… . ",
    "url": "/docs/installation",
    
    "relUrl": "/docs/installation"
  },"20": {
    "doc": "Managing database",
    "title": "Managing database",
    "content": " ",
    "url": "/docs/rosemary/managing_database",
    
    "relUrl": "/docs/rosemary/managing_database"
  },"21": {
    "doc": "Manual installation",
    "title": "Manual installation",
    "content": "Coming soon… . ",
    "url": "/docs/installation/manual_installation",
    
    "relUrl": "/docs/installation/manual_installation"
  },"22": {
    "doc": "Migrations",
    "title": "Migrations",
    "content": " ",
    "url": "/docs/rosemary/managing_database/migrations",
    
    "relUrl": "/docs/rosemary/managing_database/migrations"
  },"23": {
    "doc": "Migrations",
    "title": "Table of contents",
    "content": "If during development there are new changes in the model, run: . rosemary db:migrate . This command will detect all changes in the model (new tables, modified fields, etc.) and apply those changes to the database. ",
    "url": "/docs/rosemary/managing_database/migrations#table-of-contents",
    
    "relUrl": "/docs/rosemary/managing_database/migrations#table-of-contents"
  },"24": {
    "doc": "Modules",
    "title": "Modules",
    "content": "Coming soon… . ",
    "url": "/docs/modules",
    
    "relUrl": "/docs/modules"
  },"25": {
    "doc": "Reset database",
    "title": "Reset database",
    "content": "The rosemary db:reset command is a powerful tool for resetting your project’s database to its initial state. This command deletes all the data in your database, making it ideal for fixing any inconsistencies we may have created during development. ",
    "url": "/docs/rosemary/managing_database/reset_database",
    
    "relUrl": "/docs/rosemary/managing_database/reset_database"
  },"26": {
    "doc": "Reset database",
    "title": "Table of contents",
    "content": ". | Basic Usage | Clear migrations | . ",
    "url": "/docs/rosemary/managing_database/reset_database#table-of-contents",
    
    "relUrl": "/docs/rosemary/managing_database/reset_database#table-of-contents"
  },"27": {
    "doc": "Reset database",
    "title": "Basic Usage",
    "content": "To reset your database and clear all table data except for migration records, run: . rosemary db:reset . The rosemary db:reset command also clears the uploads directory as part of the reset process, ensuring that any files uploaded during development or testing are removed. ",
    "url": "/docs/rosemary/managing_database/reset_database#basic-usage",
    
    "relUrl": "/docs/rosemary/managing_database/reset_database#basic-usage"
  },"28": {
    "doc": "Reset database",
    "title": "Clear migrations",
    "content": "If you need to completely rebuild your database from scratch, including removing all migration history and starting fresh, you can use the --clear-migrations option: . rosemary db:reset --clear-migrations . Be careful! This command will… . | Delete all data from the database, including the migration history. | Clear the migrations directory. | Initialize a new set of migrations. | Apply the migrations to rebuild the database schema. | . ",
    "url": "/docs/rosemary/managing_database/reset_database#clear-migrations",
    
    "relUrl": "/docs/rosemary/managing_database/reset_database#clear-migrations"
  },"29": {
    "doc": "Rosemary CLI",
    "title": "Rosemary CLI",
    "content": "Rosemary is a CLI (Command Line Interface) tool developed to facilitate project management and development tasks. To use the Rosemary CLI, you need to be inside the web_app_container Docker container. This ensures that Rosemary operates in the correct environment and has access to all necessary files and settings. First, make sure your Docker environment is running. Then, access the web_app_container using the following command: . docker exec -it web_app_container /bin/sh . In the terminal, you should see the prefix /app #. You are now ready to use Rosemary’s commands. ",
    "url": "/docs/rosemary",
    
    "relUrl": "/docs/rosemary"
  },"30": {
    "doc": "Routes",
    "title": "Routes",
    "content": "The rosemary command route:list allows you to list all the routes available in the project. This command is useful for getting a quick overview of available endpoints and their corresponding HTTP methods. ",
    "url": "/docs/rosemary/routes",
    
    "relUrl": "/docs/rosemary/routes"
  },"31": {
    "doc": "Routes",
    "title": "Table of contents",
    "content": ". | List all routes | Group routes by module | List routes of a specific module | . ",
    "url": "/docs/rosemary/routes#table-of-contents",
    
    "relUrl": "/docs/rosemary/routes#table-of-contents"
  },"32": {
    "doc": "Routes",
    "title": "List all routes",
    "content": "To list all the routes of all the modules, run: . rosemary route:list . ",
    "url": "/docs/rosemary/routes#list-all-routes",
    
    "relUrl": "/docs/rosemary/routes#list-all-routes"
  },"33": {
    "doc": "Routes",
    "title": "Group routes by module",
    "content": "To get a grouped view of the routes by module, you can use the --group option. This is especially useful for applications with a complex modular structure, as it allows you to quickly see how the routes are organized within different parts of your application. rosemary route:list --group . ",
    "url": "/docs/rosemary/routes#group-routes-by-module",
    
    "relUrl": "/docs/rosemary/routes#group-routes-by-module"
  },"34": {
    "doc": "Routes",
    "title": "List routes of a specific module",
    "content": "It may be useful to see the routes associated with a specific module. To do this, simply provide the module name as an argument: . rosemary route:list &lt;module_name&gt; . Replace &lt;module_name&gt; with the actual name of the module for which you want to see the routes. ",
    "url": "/docs/rosemary/routes#list-routes-of-a-specific-module",
    
    "relUrl": "/docs/rosemary/routes#list-routes-of-a-specific-module"
  },"35": {
    "doc": "Seeders",
    "title": "Seeders",
    "content": " ",
    "url": "/docs/rosemary/managing_database/seeders",
    
    "relUrl": "/docs/rosemary/managing_database/seeders"
  },"36": {
    "doc": "Seeders",
    "title": "Table of contents",
    "content": ". | Basic Usage . | Populate from all modules | Populate from specific module | . | Reset database before populating . | Reset all modules test data | Reset test data of specific module | . | . ",
    "url": "/docs/rosemary/managing_database/seeders#table-of-contents",
    
    "relUrl": "/docs/rosemary/managing_database/seeders#table-of-contents"
  },"37": {
    "doc": "Seeders",
    "title": "Basic Usage",
    "content": "It is possible to populate the database with predefined test data. It is very useful for testing certain that require existing data. Populate from all modules . To populate all test data of all modules, run: . rosemary db:seed . Populate from specific module . If we only want to popularize the test data of a specific module, run: . rosemary db:seed &lt;module_name&gt; . Replace &lt;module_name&gt; with the name of the module you want to populate (for example, auth for the authentication module). ",
    "url": "/docs/rosemary/managing_database/seeders#basic-usage",
    
    "relUrl": "/docs/rosemary/managing_database/seeders#basic-usage"
  },"38": {
    "doc": "Seeders",
    "title": "Reset database before populating",
    "content": "If you want to make sure that the database is in a clean state before populating it with test data, you can use the --reset flag. This will reset the database to its initial state before running the seeders: . Reset all modules test data . rosemary db:seed --reset . Reset test data of specific module . You can also combine the --reset flag with a module specification if you want to reset the database before populating only the test data of a specific module: . rosemary db:seed &lt;module_name&gt; --reset . ",
    "url": "/docs/rosemary/managing_database/seeders#reset-database-before-populating",
    
    "relUrl": "/docs/rosemary/managing_database/seeders#reset-database-before-populating"
  },"39": {
    "doc": "Test coverage",
    "title": "Test coverage",
    "content": "The rosemary coverage command facilitates running code coverage analysis for your Flask project using pytest-cov. This command simplifies the process of assessing test coverage. ",
    "url": "/docs/rosemary/testing/test_coverage",
    
    "relUrl": "/docs/rosemary/testing/test_coverage"
  },"40": {
    "doc": "Test coverage",
    "title": "Table of contents",
    "content": ". | Test coverage of all modules | Test coverage of a specific module | Command Options . | --html | . | . ",
    "url": "/docs/rosemary/testing/test_coverage#table-of-contents",
    
    "relUrl": "/docs/rosemary/testing/test_coverage#table-of-contents"
  },"41": {
    "doc": "Test coverage",
    "title": "Test coverage of all modules",
    "content": "To run coverage analysis for all modules within the app/blueprints directory and generate an HTML report, use: . rosemary coverage . ",
    "url": "/docs/rosemary/testing/test_coverage#test-coverage-of-all-modules",
    
    "relUrl": "/docs/rosemary/testing/test_coverage#test-coverage-of-all-modules"
  },"42": {
    "doc": "Test coverage",
    "title": "Test coverage of a specific module",
    "content": "If you wish to run coverage analysis for a specific module, include the module name: . rosemary coverage &lt;module_name&gt; . ",
    "url": "/docs/rosemary/testing/test_coverage#test-coverage-of-a-specific-module",
    
    "relUrl": "/docs/rosemary/testing/test_coverage#test-coverage-of-a-specific-module"
  },"43": {
    "doc": "Test coverage",
    "title": "Command Options",
    "content": "--html . This option generates an HTML coverage report. The report is saved in the htmlcov directory at the root of your project. rosemary coverage --html . ",
    "url": "/docs/rosemary/testing/test_coverage#command-options",
    
    "relUrl": "/docs/rosemary/testing/test_coverage#command-options"
  },"44": {
    "doc": "Testing",
    "title": "Testing",
    "content": " ",
    "url": "/docs/rosemary/testing",
    
    "relUrl": "/docs/rosemary/testing"
  },"45": {
    "doc": "Unit tests",
    "title": "Unit tests",
    "content": " ",
    "url": "/docs/rosemary/testing/unit_tests",
    
    "relUrl": "/docs/rosemary/testing/unit_tests"
  },"46": {
    "doc": "Unit tests",
    "title": "Table of contents",
    "content": ". | Testing all modules | Testing a specific module | . ",
    "url": "/docs/rosemary/testing/unit_tests#table-of-contents",
    
    "relUrl": "/docs/rosemary/testing/unit_tests#table-of-contents"
  },"47": {
    "doc": "Unit tests",
    "title": "Testing all modules",
    "content": "To run tests across all modules in the project, you can use the following command: . rosemary test . This command will execute all tests found within the app/blueprints directory, covering all the modules of the project. ",
    "url": "/docs/rosemary/testing/unit_tests#testing-all-modules",
    
    "relUrl": "/docs/rosemary/testing/unit_tests#testing-all-modules"
  },"48": {
    "doc": "Unit tests",
    "title": "Testing a specific module",
    "content": "If you’re focusing on a particular module and want to run tests only for that module, you can specify the module name as an argument: . rosemary test &lt;module_name&gt; . ",
    "url": "/docs/rosemary/testing/unit_tests#testing-a-specific-module",
    
    "relUrl": "/docs/rosemary/testing/unit_tests#testing-a-specific-module"
  }
}
